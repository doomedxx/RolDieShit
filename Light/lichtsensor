#include <avr/io.h>
#include <stdint.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include <stdbool.h>
#define BLINK_DELAY_MS 250
#define UBBRVAL 51
 
int main (void)
{
  port_init(); // Initialize port data registers
  adc_init(); // Initialize ADC
  init_connection();   
 
 while(1) {

  float light = getLight();
  
  if (light < 40)
  {
    PORTB |= _BV(PORTB5);         //rode led knippert bij weinig licht
    _delay_ms(BLINK_DELAY_MS);
  }
  else if(light > 40 && light <=50)
  {
    PORTB |= _BV(PORTB4);         //gele led knippert bij normaal licht
    _delay_ms(BLINK_DELAY_MS);
  }
  else if(light >50)
  {
    PORTB |= _BV(PORTB3);         //groene led knippert bij veel licht
    _delay_ms(BLINK_DELAY_MS);
  }
   
  /* set pin 3,4,5 low to turn led off */
  PORTB &= ~_BV(PORTB5);
  PORTB &= ~_BV(PORTB4);
  PORTB &= ~_BV(PORTB3);
  _delay_ms(BLINK_DELAY_MS);
 }
}

float getLight(void)
{
  ADMUX |= _BV(MUX0); // Set channel point to port 1
  ADCSRA |= _BV(ADSC); // Start adc measurement
  loop_until_bit_is_clear(ADCSRA, ADSC);  // proceed when done

  float lightLevel = (float)ADCW / 1024 * 100;
  return lightLevel;
}

void port_init(void){
  DDRC &= ~_BV(DDC0); // Analog pin 0 input Light
   /* set pin 3,4,5 of PORTB for output*/
 DDRB |= _BV(DDB5);   //rode led
 DDRB |= _BV(DDB4);   //gele led
 DDRB |= _BV(DDB3);   //groene led
}

void adc_init(void){
  ADCSRA |= _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0); // 128 prescaler
  ADMUX |= _BV(REFS0);
  ADMUX &= ~_BV(REFS1); // 5v mode
  ADCSRA |= _BV(ADEN); // Turn on
}

void init_connection()
{
  // Set baudrate 19200
  UBRR0H = 0;
  UBRR0L = UBBRVAL;
  // disable U2X mode
  UCSR0A = 0;
  // enable transmitter
  UCSR0B = _BV(TXEN0) | _BV(RXEN0);
  // set frame format : asynchronous, 8 data bits, 1 stop bit, no parity
  UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
}

void send_data(uint8_t data)
{
  //UDRE is set when the transmit buffer is empty
  loop_until_bit_is_set (UCSR0A , UDRE0);
  //send the data
  UDR0 = data;
}
